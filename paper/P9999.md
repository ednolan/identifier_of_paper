---
title: "identifier_of Should Return std::string"
document: P9999R0
date: 2025-12-14
audience:
  - LEWG
  - EWG
author:
  - name: Eddie Nolan
    email: <eddiejnolan@gmail.com>
toc: true
monofont: "DejaVu Sans Mono"

---

# Status Quo

The current wording for `[meta.syn]` states:

Any function in namespace `std::meta` whose return type is `string_view` or `u8string_view` returns an object `V` such that `V.data()[V.size()]` equals `'\0'`.

\[ *Example 2:*

```c++
struct C { };

constexpr string_view sv = identifier_of(^^C);
static_assert(sv == "C");
static_assert(sv.data()[0] == 'C');
static_assert(sv.data()[1] == '\0');
```
\- *end example* \]

The relevant `std::meta` functions are `symbol_of`, `identifier_of`, and `display_string_of`, and their `u8` equivalents.

# Problems

## Teaching

The antipattern of contextually relying on `std::string_view` to have a null-terminated backing array is something we want to discourage.

For example, code like this is sometimes seen in the wild:

```
// precondition: sv is backed by a null-terminated byte string
void pass_to_c_api(std::string_view sv) {
  my_c_api(sv.data());
}
```

Since the precondition isn't enforced by the type system, it's easy to pass this function a string_view that isn't null-terminated and invoke UB within the C function that expects a C string.

This is the motivation for `std::cstring_view` ([@P3655R3]).

Despite the fact that we teach users not to do this, however, we're now standardizing a `std::string_view` that provides users exactly the guarantees we are telling them we don't want them relying on.

## Tooling

If this was only a teachability problem, one could argue for the status quo by saying that the standard is not a tutorial. However, this situation also affects tooling. Compiler authors may want to implement a check that ensures that users are not accessing memory past `size()` using a `string_view`. But with the current design, it could flag code that the standard has explicitly blessed, impeding its usefulness.

## Discoverability

Furthermore, if a user *does* need a null terminator, the interface doesn't make clear that one is present.

## Library UB

Finally, if a user attempts to access the null terminator by writing `str[str.size()]`, they violate the precondition of `std::string_view`'s `operator[]`. They instead need to write `str.data() + str.size()`. This is tricky.

# Inconsistency

# Return `std::string`

# Alternative Solutions

## Don't Null-Terminate the `std::string_view`

## Wait for `std::cstring_view` in C++29

# Ergonomics

# Compilation Performance and Memory Usage

# Wording
