---
title: "identifier_of Should Return std::string"
document: P9999R0
date: 2025-12-14
audience:
  - LEWG
  - EWG
author:
  - name: Eddie Nolan
    email: <eddiejnolan@gmail.com>
toc: true
monofont: "DejaVu Sans Mono"

---

# Status Quo

The current wording for `[meta.syn]` states:

Any function in namespace `std::meta` whose return type is `string_view` or `u8string_view` returns an object `V` such that `V.data()[V.size()]` equals `'\0'`.

\[ *Example 2:*

```c++
struct C { };

constexpr string_view sv = identifier_of(^^C);
static_assert(sv == "C");
static_assert(sv.data()[0] == 'C');
static_assert(sv.data()[1] == '\0');
```
\- *end example* \]

The relevant `std::meta` functions are `symbol_of`, `identifier_of`, and `display_string_of`, and their `u8` equivalents.

# Problems

## Teaching

The antipattern of contextually relying on `std::string_view` to have a null-terminated backing array is something we want to discourage.

For example, code like this is sometimes seen in the wild:

```
// precondition: sv is backed by a null-terminated byte string
void pass_to_c_api(std::string_view sv) {
  my_c_api(sv.data());
}
```

Since the precondition isn't enforced by the type system, it's easy to pass this function a string_view that isn't null-terminated and invoke UB within the C function that expects a C string.

This is the motivation for `std::cstring_view` ([@P3655R3]).

Despite the fact that we teach users not to do this, however, we're now standardizing a `std::string_view` that provides users exactly the guarantees we are telling them we don't want them relying on.

## Tooling

If this was only a teachability problem, one could argue for the status quo by saying that the standard is not a tutorial. However, this situation also affects tooling. Compiler authors may want to implement a check that ensures that users are not accessing memory past `size()` using a `string_view`. But with the current design, it could flag code that the standard has explicitly blessed, impeding its usefulness.

## Discoverability

Furthermore, if a user *does* need a null terminator, the interface doesn't make clear that one is present.

## Library UB

Finally, if a user attempts to access the null terminator by writing `str[str.size()]`, they violate the precondition of `std::string_view`'s `operator[]`. They instead need to write `str.data() + str.size()`. This is tricky.

# Inconsistency

In the reflection API, the `string_view`-returning functions give out a view to static storage data. Elsewhere in the API, however, we just return a container; for example, `members_of` returns `vector<info>` rather than `span<info const>`. It would be more consistent with `members_of` to have the `string_view`-returning functions return `string` instead.

# Return `std::string`

This is what this paper proposes. It's a simple solution that solves the problems with the null-terminated `string_view` while restoring consistency with the design direction used by `members_of`. We already use `string` elsewhere in the reflection API in `data_member_options` and `std::meta::exception`.

# Compilation Performance and Memory Usage

Unfortunately, the current revision of this paper does not have concrete numbers to inform the following discussion. But implementers have had competing design concerns relating to this issue.

On the one hand, some implementers are primarily concerned with memory pressure. We believe that the original motivation for `members_of` to return `vector<info>` rather than `span<info const>` was because of this; we didn't want to cause the compiler to incur an allocation every time it was invoked, especially since those allocations can't be optimized away (since users rely on the lifetimes of the static storage data) whereas any corresponding increases in constant execution time can eventually be optimized further.

On the other hand, other implementers believe that the memory pressure concerns can be alleviated by more aggresive reclamation of data that isn't exposed by the constant expression, and claim that the performance differences between `std::string_view` and `std::string` for constant evaluation comprise multiple orders of magnitude, due to the fact that `std::string_view` is possible to model in the frontend whereas `std::string` is too complex to do so.

# Alternative Solutions

## Don't Null-Terminate the `std::string_view`

This is a more minimal change that addresses most of the concerns with the null-terminated `std::string_view`. However:

- It's inconsistent with `members_of` in that it's still giving out a view to static storage data
- It doesn't address the memory pressure concerns with giving out static storage data, described in the previous section

## Wait for `std::cstring_view` in C++29

The advantage of this approach is that we don't need to make a change in the C++26 time frame, and the number of users who'd be affected by this API change is minimal, since `std::string_view` and `std::cstring_view` are so similar.

The disadvantages are that it still is inconsistent with `members_of`, and still raises memory pressure concerns; and that we'd have standardized a problematic interface for C++26 with no guarantee that the `std::cstring_view` change would actually be viable in C++29.

# Ergonomics



# Wording

# Thanks

Thanks to Corentin Jabot, Barry Revzin, Daveed Vandevoorde, and Dan Katz, who discussed this topic in an email thread from which most of the information in this paper was taken.
